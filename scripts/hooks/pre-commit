#!/bin/sh
#
# Pre-commit hook for Writeo
# Runs security checks, code formatting, linting, and type checking before commit
#

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

echo "${GREEN}Running pre-commit checks...${NC}"

# Get the root directory of the git repository
ROOT_DIR=$(git rev-parse --show-toplevel)
cd "$ROOT_DIR"

# Step 0: Security check - prevent committing sensitive files
echo "${YELLOW}Checking for sensitive files...${NC}"
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM)

if [ -n "$STAGED_FILES" ]; then
  SENSITIVE_PATTERNS="\.dev\.vars$|\.env$|\.env\.local$|\.env\..*\.local$|\.env\.production$|\.env\.development$|.*\.pem$|.*\.key$"
  BLOCKED_FILES=$(echo "$STAGED_FILES" | grep -E "$SENSITIVE_PATTERNS" || true)
  
  if [ -n "$BLOCKED_FILES" ]; then
    echo "${RED}‚ùå SECURITY ERROR: Attempted to commit sensitive files!${NC}"
    echo ""
    echo "${YELLOW}The following files contain secrets and cannot be committed:${NC}"
    echo "$BLOCKED_FILES" | sed 's/^/  - /'
    echo ""
    echo "${RED}Please remove these files from staging:${NC}"
    echo "  git reset HEAD <file>"
    echo ""
    echo "${YELLOW}If you need to commit a template file, rename it (e.g., .env.example)${NC}"
    exit 1
  fi
fi

echo "${GREEN}Security check passed.${NC}"

# Step 1: Format code with Prettier (only staged files for speed)
echo "${YELLOW}Formatting code with Prettier...${NC}"
STAGED_TS_FILES=$(echo "$STAGED_FILES" | grep -E "\.(ts|tsx|js|jsx|json|md)$" || true)
if [ -n "$STAGED_TS_FILES" ]; then
  # Check if formatting is needed first
  if echo "$STAGED_TS_FILES" | xargs npx prettier --check > /dev/null 2>&1; then
    echo "${GREEN}Code already formatted.${NC}"
  else
    echo "${YELLOW}Code formatting issues detected. Auto-formatting...${NC}"
    echo "$STAGED_TS_FILES" | xargs npx prettier --write
    echo "$STAGED_TS_FILES" | xargs git add
    echo "${GREEN}Code formatted and staged.${NC}"
  fi
else
  echo "${GREEN}No code files to format.${NC}"
fi

# Step 2: Run linting
echo "${YELLOW}Running linter...${NC}"
if ! npm run lint; then
  echo "${RED}Linting failed. Please fix the errors above.${NC}"
  echo "${YELLOW}To skip this check, use: git commit --no-verify${NC}"
  exit 1
fi

# Step 3: Run TypeScript type checking
echo "${YELLOW}Running TypeScript type checker...${NC}"
if ! npm run type-check; then
  echo "${RED}TypeScript type checking failed. Please fix the errors above.${NC}"
  echo "${YELLOW}To skip this check, use: git commit --no-verify${NC}"
  exit 1
fi

# Step 3.5: Run unit tests (fast, catches issues early)
echo "${YELLOW}Running unit tests...${NC}"
if ! npm run test:unit; then
  echo "${RED}Unit tests failed. Please fix the errors above.${NC}"
  echo "${YELLOW}To skip this check, use: git commit --no-verify${NC}"
  exit 1
fi
echo "${GREEN}Unit tests passed.${NC}"

# Step 4: Check for Python files and run Python checks
PYTHON_FILES=$(echo "$STAGED_FILES" | grep -E "\.py$" || true)
if [ -n "$PYTHON_FILES" ]; then
  echo "${YELLOW}Python files detected. Running Python checks...${NC}"
  
  # Install ruff if not available
  if ! command -v ruff > /dev/null 2>&1; then
    echo "${YELLOW}Installing ruff...${NC}"
    if command -v uv > /dev/null 2>&1; then
      uv pip install ruff > /dev/null 2>&1 || pip install ruff > /dev/null 2>&1
    else
      pip install ruff > /dev/null 2>&1 || {
        echo "${RED}Failed to install ruff. Please install manually: pip install ruff${NC}"
        exit 1
      }
    fi
  fi
  
  # Install mypy if not available
  if ! command -v mypy > /dev/null 2>&1; then
    echo "${YELLOW}Installing mypy...${NC}"
    if command -v uv > /dev/null 2>&1; then
      uv pip install mypy > /dev/null 2>&1 || pip install mypy > /dev/null 2>&1
    else
      pip install mypy > /dev/null 2>&1 || {
        echo "${RED}Failed to install mypy. Please install manually: pip install mypy${NC}"
        exit 1
      }
    fi
  fi
  
  # Format Python code
  echo "${YELLOW}Formatting Python code with ruff...${NC}"
  if ! ruff format --check . > /dev/null 2>&1; then
    echo "${YELLOW}Python formatting issues detected. Auto-formatting...${NC}"
    ruff format .
    # Stage the formatted files
    git add -u
    echo "${GREEN}Python code formatted and staged.${NC}"
  fi
  
  # Auto-fix Python linting errors
  echo "${YELLOW}Auto-fixing Python linting errors with ruff...${NC}"
  ruff check --fix --unsafe-fixes . || true
  
  # Lint Python code (strict - fails on errors)
  echo "${YELLOW}Linting Python code with ruff (strict)...${NC}"
  if ! ruff check .; then
    echo "${RED}Python linting failed. Please fix the errors above.${NC}"
    echo "${YELLOW}To skip this check, use: git commit --no-verify${NC}"
    exit 1
  fi
  
  # Type check Python code (strict - fails on errors)
  echo "${YELLOW}Running Python type checker (mypy - strict)...${NC}"
  PYTHON_ERRORS=0
  
  # Find all directories with pyproject.toml files that contain mypy configuration
  # This automatically discovers all Python projects that should be type-checked
  PYTHON_MYPY_DIRS=$(find . -name "pyproject.toml" -type f -exec grep -l "\[tool\.mypy\]" {} \; 2>/dev/null | sed 's|/pyproject.toml||' | sed 's|^\./||' | sort)
  
  if [ -z "$PYTHON_MYPY_DIRS" ]; then
    echo "${YELLOW}No Python projects with mypy configuration found.${NC}"
  else
    for dir in $PYTHON_MYPY_DIRS; do
      if [ -d "$dir" ] && [ -f "$dir/pyproject.toml" ]; then
        echo "${YELLOW}Checking $dir...${NC}"
        # Run mypy and filter out internal errors (which we can't fix)
        mypy_output=$(mypy "$dir" --config-file "$dir/pyproject.toml" 2>&1 | grep -v "INTERNAL ERROR" || true)
        mypy_exit_code=$?
        
        # Check if there are actual type errors (not just internal errors)
        if echo "$mypy_output" | grep -q "error:"; then
          echo "$mypy_output"
          PYTHON_ERRORS=$((PYTHON_ERRORS + 1))
        elif [ $mypy_exit_code -ne 0 ] && ! echo "$mypy_output" | grep -q "Success:"; then
          # Mypy failed but we didn't see the error message (shouldn't happen, but be safe)
          echo "$mypy_output"
          PYTHON_ERRORS=$((PYTHON_ERRORS + 1))
        fi
      fi
    done
  fi

  if [ $PYTHON_ERRORS -gt 0 ]; then
    echo "${RED}Python type checking failed in $PYTHON_ERRORS directory(ies).${NC}"
    echo "${YELLOW}To skip this check, use: git commit --no-verify${NC}"
    exit 1
  fi
  
  echo "${GREEN}Python checks passed.${NC}"
fi

# Step 5: Validate commit message format (optional but helpful)
COMMIT_MSG_FILE="$1"
if [ -f "$COMMIT_MSG_FILE" ]; then
  COMMIT_MSG=$(cat "$COMMIT_MSG_FILE")
  # Check for very short messages (likely typos)
  if [ ${#COMMIT_MSG} -lt 10 ] && [ ${#COMMIT_MSG} -gt 0 ]; then
    echo "${YELLOW}‚ö†Ô∏è  Warning: Commit message is very short. Consider adding more detail.${NC}"
  fi
  # Check for common mistakes
  if echo "$COMMIT_MSG" | grep -qiE "^(fix|wip|test|debug)"; then
    if ! echo "$COMMIT_MSG" | grep -qiE "^(fix|feat|chore|docs|style|refactor|test|perf|ci|build|revert):"; then
      echo "${YELLOW}üí° Tip: Consider using conventional commit format: 'type: description'${NC}"
      echo "${YELLOW}   Example: 'fix: resolve type error in auth middleware'${NC}"
    fi
  fi
fi

echo "${GREEN}All pre-commit checks passed!${NC}"
exit 0
