name: Deploy and Test

on:
  push:
    branches: [main]
  workflow_dispatch:

env:
  NODE_VERSION: "20"
  PRODUCTION_WEB_URL: "https://writeo.tre.systems"
  PRODUCTION_API_URL: "https://writeo-api-worker.rob-gilks.workers.dev"

jobs:
  test:
    name: Run All Tests (With Mocks)
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Build shared package
        run: npm run build --workspace=@writeo/shared

      - name: Type check
        run: npm run type-check

      - name: Run unit tests (with mocks)
        # Unit tests use USE_MOCK_SERVICES=true by default to avoid API costs
        # This includes api.test.ts which tests the full submission flow with mocked services
        run: npm run test:unit
        env:
          CI: true
          USE_MOCK_SERVICES: "true"
          # Test API key for mocked services (tests/helpers.ts will use default if not set)
          TEST_API_KEY: "test-key-for-mocked-services"
          API_KEY: "test-key-for-mocked-services"

      - name: Cache Playwright browsers
        uses: actions/cache@v4
        with:
          path: ~/.cache/ms-playwright
          key: ${{ runner.os }}-playwright-${{ hashFiles('**/package-lock.json') }}-${{ hashFiles('package.json') }}
          restore-keys: |
            ${{ runner.os }}-playwright-${{ hashFiles('**/package-lock.json') }}-
            ${{ runner.os }}-playwright-

      - name: Install Playwright browsers
        run: npx playwright install --with-deps chromium

      - name: Start local dev servers and run E2E tests
        # Start API worker and web app with mocked services, then run E2E tests
        run: |
          # Ensure cleanup of background processes on exit
          trap "echo 'Cleaning up background processes...'; kill \$(cat /tmp/writeo-api-worker.pid) \$(cat /tmp/writeo-web.pid) 2>/dev/null || true; echo 'Cleanup complete.'" EXIT

          # Create log files upfront to ensure they exist
          touch /tmp/writeo-api-worker.log /tmp/writeo-web.log

          # Create .dev.vars file for API worker with test API key
          # Note: MODAL_GRADE_URL and LLM API keys are required even with mocks
          # because buildConfig validates them at startup (mocks are checked at runtime)
          cd apps/api-worker
          cat > .dev.vars << EOF
          USE_MOCK_SERVICES=true
          API_KEY=test-key-for-mocked-services
          TEST_API_KEY=test-key-for-mocked-services
          MODAL_GRADE_URL=https://mock-modal-url.modal.run
          MODAL_LT_URL=https://mock-modal-lt-url.modal.run
          LLM_PROVIDER=groq
          GROQ_API_KEY=mock-groq-key-for-ci
          OPENAI_API_KEY=mock-openai-key-for-ci
          LT_LANGUAGE=en-GB
          EOF

          echo "Starting API worker..."
          echo "Verifying wrangler is available..."
          npx wrangler --version || echo "Warning: wrangler version check failed"
          # USE_MOCK_SERVICES is set in .dev.vars, but also set in env for consistency
          USE_MOCK_SERVICES=true npm run dev > /tmp/writeo-api-worker.log 2>&1 &
          API_PID=$!
          echo $API_PID > /tmp/writeo-api-worker.pid
          echo "API worker started with PID: $API_PID"
          echo "Using mocked services (USE_MOCK_SERVICES=true)"

          # Wait a moment and check if process is still alive
          sleep 2
          if ! kill -0 $API_PID 2>/dev/null; then
            echo "❌ API worker process died immediately after start"
            echo "=== API Worker Logs ==="
            cat /tmp/writeo-api-worker.log || echo "No logs available"
            exit 1
          fi
          # Check for immediate errors in logs
          if [ -f /tmp/writeo-api-worker.log ]; then
            if grep -i "error\|failed\|fatal" /tmp/writeo-api-worker.log | head -5; then
              echo "⚠️  Early errors detected in API worker logs (may be non-fatal):"
              tail -20 /tmp/writeo-api-worker.log
            fi
          fi

          # Start web app from correct directory
          cd ../web
          echo "Starting web app..."
          echo "Verifying next is available..."
          npx next --version || echo "Warning: next version check failed"
          # Load API_KEY from .dev.vars for web app (matching pre-push hook pattern)
          # Use same API_KEY value from .dev.vars file we created
          API_KEY_FOR_WEB="test-key-for-mocked-services"
          # Set API configuration for server actions (API_BASE_URL, API_KEY) and client (NEXT_PUBLIC_API_BASE)
          API_BASE_URL="http://localhost:8787" API_KEY="$API_KEY_FOR_WEB" NEXT_PUBLIC_API_BASE="http://localhost:8787" npm run dev > /tmp/writeo-web.log 2>&1 &
          WEB_PID=$!
          echo $WEB_PID > /tmp/writeo-web.pid
          echo "Web app started with PID: $WEB_PID"

          # Wait a moment and check if process is still alive
          sleep 2
          if ! kill -0 $WEB_PID 2>/dev/null; then
            echo "❌ Web app process died immediately after start"
            echo "=== Web App Logs ==="
            cat /tmp/writeo-web.log || echo "No logs available"
            exit 1
          fi
          # Check for immediate errors in logs
          if [ -f /tmp/writeo-web.log ]; then
            if grep -i "error\|failed\|fatal" /tmp/writeo-web.log | head -5; then
              echo "⚠️  Early errors detected in web app logs (may be non-fatal):"
              tail -20 /tmp/writeo-web.log
            fi
          fi

          echo "Both processes are running. Waiting for servers to be ready..."

          # Wait for servers to be ready with health checks
          MAX_WAIT=60
          ELAPSED=0
          API_READY=false
          WEB_READY=false

          while [ $ELAPSED -lt $MAX_WAIT ]; do
            # Check if processes are still running
            if ! kill -0 $API_PID 2>/dev/null; then
              echo "❌ API worker process died"
              echo "=== API Worker Logs ==="
              cat /tmp/writeo-api-worker.log || echo "No logs available"
              exit 1
            fi
            if ! kill -0 $WEB_PID 2>/dev/null; then
              echo "❌ Web app process died"
              echo "=== Web App Logs ==="
              cat /tmp/writeo-web.log || echo "No logs available"
              exit 1
            fi
            
            # Check API worker health (try both IPv4 and IPv6)
            if [ "$API_READY" = false ]; then
              if curl -s -f --max-time 2 http://127.0.0.1:8787/health > /dev/null 2>&1 || \
                 curl -s -f --max-time 2 http://localhost:8787/health > /dev/null 2>&1; then
                API_READY=true
                echo "✓ API worker is ready"
              fi
            fi
            
            # Check web app (try both IPv4 and IPv6)
            if [ "$WEB_READY" = false ]; then
              if curl -s -f --max-time 2 http://127.0.0.1:3000 > /dev/null 2>&1 || \
                 curl -s -f --max-time 2 http://localhost:3000 > /dev/null 2>&1; then
                WEB_READY=true
                echo "✓ Web app is ready"
              fi
            fi
            
            # If both are ready, break
            if [ "$API_READY" = true ] && [ "$WEB_READY" = true ]; then
              break
            fi
            
            sleep 2
            ELAPSED=$((ELAPSED + 2))
            if [ $((ELAPSED % 10)) -eq 0 ]; then
              echo "Still waiting... (${ELAPSED}s/${MAX_WAIT}s)"
              echo "Process status:"
              ps aux | grep -E "(wrangler|next)" | grep -v grep || echo "No matching processes found"
              echo "Recent API worker logs:"
              tail -20 /tmp/writeo-api-worker.log || echo "No API logs"
              echo "Recent web app logs:"
              tail -20 /tmp/writeo-web.log || echo "No web logs"
            fi
          done

          # Check if servers are ready
          if [ "$API_READY" = false ]; then
            echo "❌ API worker failed to start within ${MAX_WAIT} seconds"
            echo "=== API Worker Logs ==="
            cat /tmp/writeo-api-worker.log || echo "No logs available"
            echo "=== Process Status ==="
            ps aux | grep -E "(wrangler|node)" | grep -v grep || echo "No matching processes"
            exit 1
          fi

          if [ "$WEB_READY" = false ]; then
            echo "❌ Web app failed to start within ${MAX_WAIT} seconds"
            echo "=== Web App Logs ==="
            cat /tmp/writeo-web.log || echo "No logs available"
            echo "=== Process Status ==="
            ps aux | grep -E "(next|node)" | grep -v grep || echo "No matching processes"
            exit 1
          fi

          echo "✓ Both servers are ready"
          echo "Servers are running in background (PIDs: $API_PID, $WEB_PID)"

          # Run API integration tests first (requires running server)
          echo "Starting API integration tests..."
          cd ../..
          # Load API_KEY from .dev.vars for tests (matching pre-push hook pattern)
          TEST_API_KEY_FOR_TESTS="test-key-for-mocked-services"
          set +e  # Temporarily disable exit on error to capture test result
          npm run test:integration
          INTEGRATION_TEST_EXIT_CODE=$?
          set -e  # Re-enable exit on error

          if [ $INTEGRATION_TEST_EXIT_CODE -ne 0 ]; then
            echo "❌ API integration tests failed (exit code: $INTEGRATION_TEST_EXIT_CODE)"
            # Cleanup before exiting
            kill $API_PID $WEB_PID 2>/dev/null || true
            sleep 2
            kill -9 $API_PID $WEB_PID 2>/dev/null || true
            exit $INTEGRATION_TEST_EXIT_CODE
          else
            echo "✓ API integration tests passed"
          fi

          # Now run E2E tests while servers are running
          echo "Starting E2E tests..."
          set +e  # Temporarily disable exit on error to capture test result
          npm run test:e2e -- --reporter=github
          TEST_EXIT_CODE=$?
          set -e  # Re-enable exit on error

          if [ $TEST_EXIT_CODE -ne 0 ]; then
            echo "❌ E2E tests failed (exit code: $TEST_EXIT_CODE)"
          else
            echo "✓ E2E tests passed"
          fi

          # Cleanup: kill background processes
          echo "Cleaning up background processes..."
          kill $API_PID $WEB_PID 2>/dev/null || true
          sleep 2
          kill -9 $API_PID $WEB_PID 2>/dev/null || true

          # Exit with test result
          exit $TEST_EXIT_CODE
        env:
          CI: true
          USE_MOCK_SERVICES: "true"
          PLAYWRIGHT_BASE_URL: "http://localhost:3000"
          API_BASE: "http://localhost:8787"
          API_BASE_URL: "http://localhost:8787"
          NEXT_PUBLIC_API_BASE: "http://localhost:8787"
          # Test API key for mocked services (used by both integration and E2E tests)
          TEST_API_KEY: "test-key-for-mocked-services"
          API_KEY: "test-key-for-mocked-services"
          WRANGLER_LOG: "info"
          WRANGLER_SEND_METRICS: "false"
          NO_UPDATE_NOTIFIER: "1"
          NEXT_TELEMETRY_DISABLED: "1"
          FORCE_COLOR: "1"

      - name: Show server logs on failure
        if: failure()
        run: |
          echo "=== API Worker Logs ==="
          tail -100 /tmp/writeo-api-worker.log || echo "No API worker logs"
          echo "=== Web App Logs ==="
          tail -100 /tmp/writeo-web.log || echo "No web app logs"

  deploy:
    name: Build and Deploy
    runs-on: ubuntu-latest
    needs: [test]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Build shared package
        run: npm run build --workspace=@writeo/shared

      - name: Deploy API Worker
        working-directory: apps/api-worker
        run: |
          npx wrangler deploy
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          # Production worker should NOT have USE_MOCK_SERVICES set (or set to false)
          # This ensures production uses real APIs

      - name: Deploy Web App
        working-directory: apps/web
        run: |
          npm run build:cf
          npx wrangler deploy
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}

  smoke-test:
    name: Smoke Test (Real APIs)
    runs-on: ubuntu-latest
    needs: [deploy]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Build shared package
        run: npm run build --workspace=@writeo/shared

      - name: Cache Playwright browsers
        uses: actions/cache@v4
        with:
          path: ~/.cache/ms-playwright
          key: ${{ runner.os }}-playwright-${{ hashFiles('**/package-lock.json') }}-${{ hashFiles('package.json') }}
          restore-keys: |
            ${{ runner.os }}-playwright-${{ hashFiles('**/package-lock.json') }}-
            ${{ runner.os }}-playwright-

      - name: Install Playwright browsers
        run: npx playwright install --with-deps chromium

      - name: Run smoke test against production
        # Single E2E submission test to verify production deployment works with real APIs
        # This is the only test that hits real Modal/Groq/OpenAI endpoints
        # Tests the full user flow: navigate, type essay, submit, view results
        run: npx playwright test tests/e2e/smoke.spec.ts --reporter=github
        env:
          CI: true
          PLAYWRIGHT_BASE_URL: ${{ env.PRODUCTION_WEB_URL }}
          API_BASE: ${{ env.PRODUCTION_API_URL }}
          API_BASE_FORCE_REMOTE: "true"
          API_KEY: ${{ secrets.TEST_API_KEY || secrets.API_KEY }}
          TEST_API_KEY: ${{ secrets.TEST_API_KEY }}
          # Explicitly disable mocks for production smoke test
          USE_MOCK_SERVICES: "false"
          # Production worker must have real API keys configured
          # and USE_MOCK_SERVICES unset or false
