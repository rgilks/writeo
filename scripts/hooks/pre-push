#!/bin/sh
#
# Pre-push hook for Writeo
# Starts local dev servers, runs all tests, then cleans up
#

set -e  # Exit immediately if a command exits with a non-zero status

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Configuration
API_URL="http://localhost:8787"
WEB_URL="http://localhost:3000"
API_HEALTH_URL="${API_URL}/health"
MAX_WAIT_TIME=60  # seconds
CHECK_INTERVAL=2  # seconds
START_TIME=$(date +%s)

# Get the root directory of the git repository
ROOT_DIR=$(git rev-parse --show-toplevel)
cd "$ROOT_DIR"

# Check for quick mode (skip E2E tests)
SKIP_E2E=false
CHECK_DOCS_ONLY=false

# Check for QUICK_PUSH environment variable
if [ "$QUICK_PUSH" = "true" ]; then
  SKIP_E2E=true
fi

# Check if only docs changed in commits being pushed
# Pre-push hook receives: $1 = remote name, $2 = remote URL
if [ "$SKIP_E2E" != "true" ]; then
  REMOTE_NAME="${1:-origin}"
  CURRENT_BRANCH=$(git symbolic-ref -q HEAD | sed 's|^refs/heads/||' || echo "")
  REMOTE_REF="$REMOTE_NAME/$CURRENT_BRANCH"
  
  # Get files changed between remote and local (what's being pushed)
  CHANGED_FILES=""
  if git rev-parse --verify "$REMOTE_REF" > /dev/null 2>&1; then
    # Compare with remote branch
    CHANGED_FILES=$(git diff --name-only "$REMOTE_REF"..HEAD 2>/dev/null || echo "")
  fi
  
  # Fallback: check last commit if we can't compare with remote
  if [ -z "$CHANGED_FILES" ]; then
    CHANGED_FILES=$(git log -1 --name-only --pretty=format:"" 2>/dev/null | grep -vE "^\s*$" || echo "")
  fi
  
  if [ -n "$CHANGED_FILES" ]; then
    # Check if any non-docs files changed (exclude markdown, yaml, docs dir, README, etc.)
    CODE_FILES=$(echo "$CHANGED_FILES" | grep -vE "\.(md|txt|yml|yaml)$|^docs/|^README|^\.github/|^\.gitignore|^LICENSE" || true)
    if [ -z "$CODE_FILES" ]; then
      CHECK_DOCS_ONLY=true
      SKIP_E2E=true
    fi
  fi
fi

# Helper function to show elapsed time
show_time() {
  local elapsed=$(($(date +%s) - START_TIME))
  echo -n "${CYAN}[${elapsed}s]${NC} "
}

# Cleanup function to kill background processes (only if we started them)
cleanup() {
  echo ""
  show_time
  echo "${YELLOW}Cleaning up dev servers...${NC}"
  
  # Only kill processes we started
  if [ ! -z "$API_PID" ] && [ "$API_RUNNING" = false ]; then
    kill $API_PID 2>/dev/null || true
    wait $API_PID 2>/dev/null || true
  fi
  
  if [ ! -z "$WEB_PID" ] && [ "$WEB_RUNNING" = false ]; then
    kill $WEB_PID 2>/dev/null || true
    wait $WEB_PID 2>/dev/null || true
  fi
  
  # Only force kill if we started the servers
  if [ "$API_RUNNING" = false ]; then
    lsof -ti:8787 | xargs kill -9 2>/dev/null || true
  fi
  if [ "$WEB_RUNNING" = false ]; then
    lsof -ti:3000 | xargs kill -9 2>/dev/null || true
  fi
  
  show_time
  echo "${GREEN}Cleanup complete.${NC}"
}

# Set trap to cleanup on exit
trap cleanup EXIT INT TERM

echo "${BLUE}========================================${NC}"
echo "${BLUE}Running pre-push tests${NC}"
echo "${BLUE}========================================${NC}"
echo ""
show_time
echo "${CYAN}This hook will:${NC}"
if [ "$CHECK_DOCS_ONLY" = "true" ]; then
  echo "  ðŸ“„ Docs-only changes detected - skipping tests"
  echo "  1. Run unit tests (quick check)"
  SKIP_E2E=true
elif [ "$SKIP_E2E" = "true" ]; then
  echo "  âš¡ Quick mode - skipping E2E tests"
  echo "  1. Check/start API worker (port 8787)"
  echo "  2. Check/start web app (port 3000)"
  echo "  3. Wait for servers to be ready"
  echo "  4. Run unit tests"
else
  echo "  1. Check/start API worker (port 8787)"
  echo "  2. Check/start web app (port 3000)"
  echo "  3. Wait for servers to be ready"
  echo "  4. Run unit tests"
  echo "  5. Run E2E tests"
fi
echo ""

# Check if servers are already running and can be reused
show_time
echo "${CYAN}Checking for existing servers...${NC}"
API_RUNNING=false
WEB_RUNNING=false

show_time
echo "${CYAN}  Checking port 8787 (API worker)...${NC}"
if lsof -ti:8787 > /dev/null 2>&1; then
  show_time
  echo "${CYAN}    Port 8787 is in use, checking if it's responding...${NC}"
  if curl -s -f --max-time 2 "$API_HEALTH_URL" > /dev/null 2>&1; then
    API_RUNNING=true
    show_time
    echo "${GREEN}    âœ“ API worker already running, reusing...${NC}"
  else
    show_time
    echo "${YELLOW}    Port 8787 in use but not responding. Cleaning up...${NC}"
    lsof -ti:8787 | xargs kill -9 2>/dev/null || true
    sleep 1
  fi
else
  show_time
  echo "${CYAN}    Port 8787 is free${NC}"
fi

show_time
echo "${CYAN}  Checking port 3000 (Web app)...${NC}"
if lsof -ti:3000 > /dev/null 2>&1; then
  show_time
  echo "${CYAN}    Port 3000 is in use, checking if it's responding...${NC}"
  if curl -s -f --max-time 2 "$WEB_URL" > /dev/null 2>&1; then
    WEB_RUNNING=true
    show_time
    echo "${GREEN}    âœ“ Web app already running, reusing...${NC}"
  else
    show_time
    echo "${YELLOW}    Port 3000 in use but not responding. Cleaning up...${NC}"
    lsof -ti:3000 | xargs kill -9 2>/dev/null || true
    sleep 1
  fi
else
  show_time
  echo "${CYAN}    Port 3000 is free${NC}"
fi

# Step 1: Start API worker (if not already running)
if [ "$API_RUNNING" = false ]; then
  show_time
  echo "${YELLOW}Starting API worker on port 8787 (with mocked LLM APIs)...${NC}"
  echo "${CYAN}  Logs: /tmp/writeo-api-worker.log${NC}"
  cd "$ROOT_DIR/apps/api-worker"
  # USE_MOCK_LLM=true enables deterministic mocked responses (saves API costs locally)
  USE_MOCK_LLM=true npm run dev > /tmp/writeo-api-worker.log 2>&1 &
  API_PID=$!
  cd "$ROOT_DIR"
  show_time
  echo "${CYAN}  API worker started (PID: $API_PID) - using mocked LLM responses${NC}"
else
  API_PID=""
fi

# Step 2: Start web app with local API configuration (if not already running)
# Load API_KEY early so we can pass it to web app
if [ -f "$ROOT_DIR/apps/api-worker/.dev.vars" ]; then
  API_KEY_FOR_WEB=$(grep "^API_KEY=" "$ROOT_DIR/apps/api-worker/.dev.vars" | cut -d'=' -f2 | tr -d '"' | tr -d "'" | head -1)
fi

if [ "$WEB_RUNNING" = false ]; then
  show_time
  echo "${YELLOW}Starting web app on port 3000...${NC}"
  echo "${CYAN}  Logs: /tmp/writeo-web.log${NC}"
  cd "$ROOT_DIR/apps/web"
  # Set API configuration for server actions (API_BASE_URL, API_KEY) and client (NEXT_PUBLIC_API_BASE)
  API_BASE_URL="$API_URL" API_KEY="${API_KEY_FOR_WEB:-}" NEXT_PUBLIC_API_BASE="$API_URL" npm run dev > /tmp/writeo-web.log 2>&1 &
  WEB_PID=$!
  cd "$ROOT_DIR"
  show_time
  echo "${CYAN}  Web app started (PID: $WEB_PID)${NC}"
else
  WEB_PID=""
fi

# Step 3: Wait for servers to be ready (only if we started them)
# Initialize ready status based on whether servers were already running
API_READY=$API_RUNNING
WEB_READY=$WEB_RUNNING

if [ "$API_RUNNING" = false ] || [ "$WEB_RUNNING" = false ]; then
  show_time
  echo "${YELLOW}Waiting for servers to be ready...${NC}"
  ELAPSED=0
  LAST_STATUS_UPDATE=0
  
  while [ $ELAPSED -lt $MAX_WAIT_TIME ]; do
    # Check API worker
    if [ "$API_READY" = false ]; then
      if curl -s -f --max-time 2 "$API_HEALTH_URL" > /dev/null 2>&1; then
        API_READY=true
        show_time
        echo "${GREEN}âœ“ API worker is ready${NC}"
      fi
    fi
    
    # Check web app
    if [ "$WEB_READY" = false ]; then
      if curl -s -f --max-time 2 "$WEB_URL" > /dev/null 2>&1; then
        WEB_READY=true
        show_time
        echo "${GREEN}âœ“ Web app is ready${NC}"
      fi
    fi
    
    # If both are ready, break
    if [ "$API_READY" = true ] && [ "$WEB_READY" = true ]; then
      break
    fi
    
    # Show status update every 5 seconds
    if [ $((ELAPSED - LAST_STATUS_UPDATE)) -ge 5 ]; then
      STATUS_MSG=""
      if [ "$API_READY" = false ]; then
        STATUS_MSG="${STATUS_MSG}API:waiting "
      fi
      if [ "$WEB_READY" = false ]; then
        STATUS_MSG="${STATUS_MSG}Web:waiting "
      fi
      if [ ! -z "$STATUS_MSG" ]; then
        show_time
        echo "${CYAN}Still waiting... ${STATUS_MSG}(${ELAPSED}s/${MAX_WAIT_TIME}s)${NC}"
      fi
      LAST_STATUS_UPDATE=$ELAPSED
    fi
    
    sleep $CHECK_INTERVAL
    ELAPSED=$((ELAPSED + CHECK_INTERVAL))
  done
  
  echo ""
fi

# Check if servers are ready (use default false if not set)
API_READY=${API_READY:-false}
WEB_READY=${WEB_READY:-false}

if [ "$API_READY" = false ]; then
  echo "${RED}Error: API worker failed to start within ${MAX_WAIT_TIME} seconds${NC}"
  echo "${YELLOW}API worker logs:${NC}"
  tail -20 /tmp/writeo-api-worker.log || true
  exit 1
fi

if [ "$WEB_READY" = false ]; then
  echo "${RED}Error: Web app failed to start within ${MAX_WAIT_TIME} seconds${NC}"
  echo "${YELLOW}Web app logs:${NC}"
  tail -20 /tmp/writeo-web.log || true
  exit 1
fi

# Step 4: Run tests
echo ""
show_time
echo "${BLUE}Running all tests...${NC}"
echo ""

# Load API_KEY from .dev.vars if it exists (for tests)
if [ -f "$ROOT_DIR/apps/api-worker/.dev.vars" ]; then
  # Extract API_KEY from .dev.vars file
  API_KEY_FROM_FILE=$(grep "^API_KEY=" "$ROOT_DIR/apps/api-worker/.dev.vars" | cut -d'=' -f2 | tr -d '"' | tr -d "'")
  if [ ! -z "$API_KEY_FROM_FILE" ]; then
    export API_KEY="$API_KEY_FROM_FILE"
  fi
fi

# Set environment variables for tests
export PLAYWRIGHT_BASE_URL="$WEB_URL"
export API_BASE="$API_URL"
# Prevent Playwright from serving HTML report (which blocks the hook)
export CI=true
# API_KEY is now loaded from .dev.vars above, or should be set in environment
# If not set, tests will fail with a clear error message

# Run unit tests first (faster, catches API issues quickly)
show_time
echo "${CYAN}Running unit tests...${NC}"
echo ""
set +e  # Temporarily disable exit on error to capture test result
npm test 2>&1
UNIT_TEST_EXIT_CODE=$?
set -e  # Re-enable exit on error
if [ $UNIT_TEST_EXIT_CODE -ne 0 ]; then
  echo ""
  show_time
  echo "${RED}âœ— Unit tests failed (exit code: $UNIT_TEST_EXIT_CODE)!${NC}"
  echo "${YELLOW}Stopping pre-push hook. To skip this check, use: git push --no-verify${NC}"
  exit 1
fi
show_time
echo "${GREEN}âœ“ Unit tests passed${NC}"

echo ""
# Run e2e tests with list reporter (non-interactive) - unless skipped
if [ "$SKIP_E2E" = "true" ]; then
  show_time
  echo "${YELLOW}â­ï¸  Skipping E2E tests${NC}"
  if [ "$CHECK_DOCS_ONLY" = "true" ]; then
    echo "  (docs-only changes detected)"
  else
    echo "  (quick mode enabled)"
    echo "  To run full tests: git push (without QUICK_PUSH=true)"
  fi
else
  # Use more workers for faster execution (config defaults to 2 for CI, 4 for local)
  show_time
  echo "${CYAN}Running E2E tests...${NC}"
  echo ""
  set +e  # Temporarily disable exit on error to capture test result
  npm run test:e2e -- --reporter=list 2>&1
  E2E_TEST_EXIT_CODE=$?
  set -e  # Re-enable exit on error
  if [ $E2E_TEST_EXIT_CODE -ne 0 ]; then
    echo ""
    show_time
    echo "${RED}âœ— E2E tests failed (exit code: $E2E_TEST_EXIT_CODE)!${NC}"
    echo "${YELLOW}Stopping pre-push hook. To skip this check, use: git push --no-verify${NC}"
    exit 1
  fi
  show_time
  echo "${GREEN}âœ“ E2E tests passed${NC}"
fi

echo ""
show_time
echo "${GREEN}========================================${NC}"
echo "${GREEN}All tests passed!${NC}"
TOTAL_TIME=$(($(date +%s) - START_TIME))
echo "${GREEN}Total time: ${TOTAL_TIME}s${NC}"
echo "${GREEN}========================================${NC}"

# Cleanup will happen automatically via trap
exit 0

